<!DOCTYPE html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>

    body {
        font: 14px sans-serif;
    }

    .axis {
        font: 10px sans-serif;
    }

    .axis path,
    .axis line {
        fill: none;
        stroke: #000;
        shape-rendering: crispEdges;
    }

    .x.axis path {
        display: none;
    }

    .max_min {
        fill: #3a0047;
    }

    .record_range {
        fill: #b8b17a;
        opacity: 0.75;

    }

    .norm_range {
        fill: #756e47;
        opacity: 0.5;

    }

    .precip_line {
        fill: none;
        stroke: #2a5c75;
        stroke-width: 2px;
    }

    .precip_mean {
        fill: none;
        stroke: #56a0de;
        stroke-width: 1px;
    }

    .precip_area {
        fill: #b8b17a;
        opacity: 0.5;
    }

    .vertGrid {
        fill: none;
        shape-rendering: crispEdges;
        stroke: black;
        stroke-dasharray: 1, 2;
        stroke-width: 1px;
    }


</style>
</head>
<body>

<h1>Re-creating the New York Times' Classic Vizualization of New York City's Weather in 2003</h1>
<h2>Created using NOAA Weather Data, Python and D3.js</h2>

<h3>Original Visualization</h3>

<p>This is a favorite of Edward Tufte. In *The Visual Display of Quantitative Information*, he cites it as an exemplar
    of high-data-density visualization, quoting a density of "better than 300 numbers per square inch"</p>

<img src="http://www.edwardtufte.com/bboard/images/00014g-836.jpg">

<h3>D3.js Static Recreation</h3>

<p>This is a static recreation of this chart using D3.js, made as a submission for an initial D3.js assignment for the
    class <a href="https://datascience.berkeley.edu/academics/curriculum/data-visualization/">Data Visualization &
        Communication</a>
    in the UC Berkeley Master of Information and Data Science program.</p>
<p/>
<p>Data is for the New York Central Park Belvedere
    Castle National Weather Service Observatory, obtained from
    <a href="ftp://ftp.ncdc.noaa.gov/pub/data/ghcn/daily/all/USW00094728.dly">NOAA's data FTP service</a>. Max/Min and
    other calculated metrics differ from the original since they are calculated on all years from start of observations
    in 1876 until 2015, rather than the reduced set used for the original in 2003.
    Code for the visualization (including a Python script to download, clean and reformat the data and calculate the
    various metrics) can be found <a href="https://github.com/janakmayer/weather_visualization">on GitHub</a>.</p>
<p/>
<p>
    This is an initial effort only. Subsequent iterations will clean up the code base, using Mike Bostock's
    <a href="http://bost.ocks.org/mike/chart/">convention for reusable charts</a> add a range of interactions, including
    the ability to select other cities and other years.
</p>

<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
<script>

var margin = {top: 40, right: 20, bottom: 20, left: 50},
    width = 1000 - margin.left - margin.right,
    height = 300 - margin.top - margin.bottom,
    sm_height = 100,
    sm_margin = {top: 10, right: 20, bottom: 40, left: 50},
    barPadding = 1;

var parseDate = d3.time.format("%Y-%m-%d %H:%M:%S").parse;

var monthNameFormat = d3.time.format('%B');

var xScale = d3.time.scale()
    .range([0, width]);

var yScale = d3.scale.linear()
    .range([height, 0]);

var xAxis = d3.svg.axis()
    .scale(xScale)
    .tickFormat(monthNameFormat)
    .orient("bottom")
    .tickSize(0);

var yAxis = d3.svg.axis()
    .scale(yScale)
    .orient("left");

//var line = d3.svg.line()
//    .x(function(d) { return xScale(d.date); })
//    .y(function(d) { return yScale(d.cumprcp); });
//
//var area = d3.svg.area()
//    .x(function(d) { return xScale(d.date); })
//    .y(function(d) { return yScale(d.cumprcp); })
//    .y0(sm_height);



var svg = d3.select("body").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
    .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

// Add a second svg for the small multiples
var sm_svg = d3.select("body").append("svg")
    .attr("width", width + sm_margin.left + sm_margin.right)
    .attr("height", sm_height + sm_margin.top + sm_margin.bottom)
    .append("g")
    .attr("transform", "translate(" + sm_margin.left + "," + sm_margin.top + ")");

// calculate the pixel-width of the timeScale tick marks
function tickWidthToPixels(scale, d, i) {
    var next = i == scale.ticks().length -1 ? scale.range()[1] : scale(scale.ticks()[i+1]);
    return next - scale(d)


}

d3.csv("NY2003Weather.csv", function(error, data) {
    if (error) throw error;

    data.forEach(function(d) {
        d.date = parseDate(d.date);
        d.month = monthNameFormat(d.date);
        d.tmax = +d.tmax;
        d.tmin = +d.tmin;
        d.tmin = +d.tmin;
        d.rhigh = +d.rhigh;
        d.rlow = +d.rlow;
        d.nhigh = +d.nhigh;
        d.nlow = +d.nlow;
        d.cumprcp = +d.cumprcp;
        d.meanprcp = +d.meanprcp;
    });

    // Use d3.nest to group data by month for the small multiples charts
    var nested = d3.nest()
        .key(function(d) { return d.month; })
        .sortValues(function(a, b) { return d3.ascending(a.date, b.date); })
        .entries(data);

    xScale.domain(d3.extent(data, function(d) { return d.date; }));
    yScale.domain([d3.min(data, function(d) { return d.rlow; }),d3.max(data, function(d) { return d.rhigh; })]);

    svg.append("g")
        .attr({
            "class": "x axis",
            "transform": "translate(" + xScale.range()[1] / 24 + "," + -20  + ")"
        })
        .call(xAxis);

    svg.selectAll(".record_range")
        .data(data)
        .enter()
        .append("rect")
        .attr({
            "class": "record_range",
            "x": function (d) { return xScale(d.date); },
            "width": width / data.length,
            "y": function (d) { return yScale(d.rhigh); },
            "height": function (d) { return yScale(d.rlow) - yScale(d.rhigh); }
        });

    svg.selectAll(".norm_range")
        .data(data)
        .enter()
        .append("rect")
        .attr({
            "class": "norm_range",
            "x": function (d) { return xScale(d.date); },
            "width": width / data.length,
            "y": function (d) { return yScale(d.nhigh); },
            "height": function (d) { return yScale(d.nlow) - yScale(d.nhigh); }
        });

    svg.selectAll(".max_min")
        .data(data)
        .enter()
        .append("rect")
        .attr({
            "class": "max_min",
            "x": function (d) { return xScale(d.date); },
            "width": width / data.length - barPadding,
            "y": function (d) { return yScale(d.tmax); },
            "height": function (d) { return yScale(d.tmin) - yScale(d.tmax); }
        });


    svg.append("g")
        .attr("class", "y axis")
        .call(yAxis)
        .append("text")
        .attr({
            "transform": "rotate(-90)",
            "y": 6,
            "dy": ".71em",
            "text-anchor": "end"
        })
        .style()
        .text("Temperature (Deg F)");

    svg.selectAll(".vertGrid")
        .data(xScale.ticks())
        .enter()
        .append("line")
        .attr({
            "class":"vertGrid",
            "x1" : function(d){ return xScale(d) },
            "x2" : function(d){ return xScale(d) },
            "y1" : 0,
            "y2" : height
        });



    // Now we do the small multiples
    var sm_yScale = d3.scale.linear()
        .domain([0,Math.ceil(d3.max(data, function(d) { return d.cumprcp; }))])
        .range([sm_height, 0]);

    var sm_yAxis = d3.svg.axis()
        .scale(sm_yScale)
        .orient("left");

    sm_svg.append("g")
        .attr("class", "y axis")
        .call(sm_yAxis)
        .append("text")
        .attr({
            "transform": "rotate(-90)",
            "y": 6,
            "dy": ".71em",
            "text-anchor": "end"
        })
        .style()
        .text("Precipitation (in)");


    sm_svg.append("g")
        .attr({
            "class": "x axis",
            "transform": "translate(" + xScale.range()[1] / 24 + "," + 110  + ")"
        })
        .call(xAxis);

    var sm = sm_svg.selectAll(".smallMultiples");

    sm
        .data(xScale.ticks())
        .enter()
        .append("line")
        .attr({
            "class":"vertGrid",
            "x1" : function(d){ return xScale(d) },
            "x2" : function(d){ return xScale(d) },
            "y1" : 0,
            "y2" : sm_height
        });

    sm
        .data(xScale.ticks())
        .enter()
        .append("g")
        .each(function(d,i) {

            var x_origin = xScale(d);
            var x_extent = x_origin + tickWidthToPixels(xScale, d, i);

            var sm_xScale = d3.time.scale()
                .domain(d3.extent(nested[i].values, function(d) { return d.date; }))
                .range([x_origin, x_extent]);


            var cum_precip_line = d3.svg.line()
                .x(function(d) { return sm_xScale(d.date); })
                .y(function(d) { return sm_yScale(d.cumprcp); });

            var mean_precip_line = d3.svg.line()
                .x(function(d) { return sm_xScale(d.date); })
                .y(function(d) { return sm_yScale(d.meanprcp); });

            var area = d3.svg.area()
                .x(function(d) { return sm_xScale(d.date); })
                .y(function(d) { return sm_yScale(d.cumprcp); })
                .y0(sm_height);

            d3.select(this)
                .append("path")
                .datum(nested[i].values)
                .attr("class", "precip_area")
                .attr("d", area);

            d3.select(this)
                .append("path")
                .datum(nested[i].values)
                .attr("class", "precip_mean")
                .attr("d", mean_precip_line);

            d3.select(this)
                .append("path")
                .datum(nested[i].values)
                .attr("class", "precip_line")
                .attr("d", cum_precip_line);
        });



});

</script>
</body>